---
title: 2018-3随笔笔记
date:   2018/3/1
categories: 
    - 学习 
    - 随笔笔记
tags:
    - vue
---
### 给点击路由的时候加上监听事件
```html
<router-link class="my-link" :to="{name: 'main.provider.index', params: {providerId: scope.row.providerId}}">提供者主页</router-link>
```
    解决方法：
    > 给组件绑定原生事件
        有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 v-on 的修饰符 .native。例如：

        <my-component v-on:click.native="doTheThing"></my-component>

参考连接
[给组件绑定原生事件](https://segmentfault.com/q/1010000007896386)

### 块内元素文字上下居中
line-height设置为height的值

### export及export default的区别
在一个文件或模块中，export可以有多个，export default仅有一个。 
    
- export

(1) 导入的时候带花括号

    ```javascript
        // 写法一
        export var m = 1;

        // 写法二
        var m = 1;
        export {m}; //export m 或者export 1都错误

        // 写法三
        var n = 1;
        export {n as m};
    ```

(2) export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。

- export default 

(1) 导入的时候没有花括号

    ```javascript
        import str from 'demo1' //导入的时候没有花括号
    ```

(2) export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。

### 用refs来组件通信
在讨论非父子通信的时候，并在没有用Vuex的情况下，我是用官网那种创建Vue实例的方法，但是同事提到了另一种方法
用refs来引用，不禁一想这好像也是一种解决方案，就是觉得怪怪的。在这里记录一下

### 浏览器缓存机制
[https://www.cnblogs.com/shixiaomiao1122/p/7591556.html](https://www.cnblogs.com/shixiaomiao1122/p/7591556.html)
[https://www.cnblogs.com/slly/p/6732749.html](https://www.cnblogs.com/slly/p/6732749.html)

判断缓存是否过期步骤是：
- 不发生请求 强缓存：
    **s-maxage优先于max-age优先于expires**

    1） 查看是否有cache-control 的max-age / s-maxage , 如果有，则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间，将当前时间与过期时间进行比较，判断是否过期

    2）查看是否有cache-control 的max-age / s-maxage，如果没有，则用expires 作为过期时间比较

- 发送请求

    3）Last-Modified与ETag，**ETag优先于Last-Modified**

        Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：

        1. Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度
        2. 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存
        3. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形

{% asset_img cache.png 浏览器缓存机制 %}
{% asset_img cache2.png 浏览器缓存机制 %}

{% asset_img user_cache.png 用户行为影响浏览器缓存 %}

浏览器的缓存来源是怎么设置的？

{% asset_img cache_from.png 浏览器缓存来源 %}

看到知乎有人讨论 [https://www.zhihu.com/question/64201378](https://www.zhihu.com/question/64201378)


    
### 关于第4点，今天工作用了this.$refs来传播事件，类似于$brocast,但是VUE2把$brocast废除了。

总结一下vue传播事件

(1) 子组件传播事件给父组件，用``$on,$emit``.

虽然说是这样说，但是不是直接在父组件里面写$on的,应该是这样

```html
<parent>
    <child @eventname="event">
</parent>
```
然后在parent组件里面写 event函数.event(){}

子组件调用的时候用``this.$emit('eventname',payload) ``

(2)父组件传播事件给子组件，用 ``$refs``

```html
<parent>
    <child ref="refname">
</parant>
```

调用的时候用``this.$ref['refname'].eventname()``

(3)创建实例bus


###  js的数组可以是这样的形式

``(4) [{…}, {…}, {…}, {…}, total: 4, code: "core.ok", __ob__: Observer]``

他的length是4，不知道是不是ES6的新特性
我把下面这句在浏览器下运行是出错的

``let arr= [{id:1}, {id:2}, {id:3}, {id:4}, total: 4, code: "core.ok"];``
    
### 把字符串转换成数字可以用数字运算符,但是 + 不行
```javascript
console.log("2">>>0)  //2 number 
console.log("2">>0)  //2 number 
console.log("2"<<0)  //2 number  没有（<<<）
console.log("2"- 0)    //2 number
console.log("2"+0)    //20 string
```

### reduce函数好好用

今天写了一个有重大作用的reduce函数，好开心。在此纪念一下

```javascript
//str {String}, "app.get.logo.list"
//ctx {Object},  this._$http
//return {Object}, this._$http.app.get.logo.list
 getBackend(str){
        const arr = this.loadBackend.split('.');
        let ctx= this._$http;
        let a;
        let b=arr.reduce((prev, cur, idx) => {		        
              a = prev[cur] ;         
            return a;
        },ctx);              
          return b;      
      }
```