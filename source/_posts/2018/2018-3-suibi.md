---
title: 2018-3随笔笔记
date:   2018/3/1
categories: 
    - 学习 
    - 随笔笔记
tags:
    - vue
    - ES6 
---
### 给点击路由的时候加上监听事件
```html
<router-link class="my-link" :to="{name: 'main.provider.index', params: {providerId: scope.row.providerId}}">提供者主页</router-link>
```
    解决方法：
    > 给组件绑定原生事件
        有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 v-on 的修饰符 .native。例如：

        <my-component v-on:click.native="doTheThing"></my-component>

参考连接
[给组件绑定原生事件](https://segmentfault.com/q/1010000007896386)

### 块内元素文字上下居中
line-height设置为height的值

### export及export default的区别
在一个文件或模块中，export可以有多个，export default仅有一个。 
    
- export

(1) 导入的时候带花括号

    ```javascript
        // 写法一
        export var m = 1;

        // 写法二
        var m = 1;
        export {m}; //export m 或者export 1都错误

        // 写法三
        var n = 1;
        export {n as m};
    ```

(2) export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。

- export default 

(1) 导入的时候没有花括号

    ```javascript
        import str from 'demo1' //导入的时候没有花括号
    ```

(2) export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。

### 用refs来组件通信
在讨论非父子通信的时候，并在没有用Vuex的情况下，我是用官网那种创建Vue实例的方法，但是同事提到了另一种方法
用refs来引用，不禁一想这好像也是一种解决方案，就是觉得怪怪的。在这里记录一下

### 浏览器缓存机制
[https://www.cnblogs.com/shixiaomiao1122/p/7591556.html](https://www.cnblogs.com/shixiaomiao1122/p/7591556.html)
[https://www.cnblogs.com/slly/p/6732749.html](https://www.cnblogs.com/slly/p/6732749.html)

判断缓存是否过期步骤是：
- 不发生请求 强缓存：
    **s-maxage优先于max-age优先于expires**

    1） 查看是否有cache-control 的max-age / s-maxage , 如果有，则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间，将当前时间与过期时间进行比较，判断是否过期

    2）查看是否有cache-control 的max-age / s-maxage，如果没有，则用expires 作为过期时间比较

- 发送请求

    3）Last-Modified与ETag，**ETag优先于Last-Modified**

        Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：

        1. Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度
        2. 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存
        3. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形

{% asset_img cache.png 浏览器缓存机制 %}
{% asset_img cache2.png 浏览器缓存机制 %}

{% asset_img user_cache.png 用户行为影响浏览器缓存 %}

浏览器的缓存来源是怎么设置的？

{% asset_img cache_from.png 浏览器缓存来源 %}

看到知乎有人讨论 [https://www.zhihu.com/question/64201378](https://www.zhihu.com/question/64201378)


    
### 关于第4点，今天工作用了this.$refs来传播事件，类似于$brocast,但是VUE2把$brocast废除了。

总结一下vue传播事件

(1) 子组件传播事件给父组件，用``$on,$emit``.

虽然说是这样说，但是不是直接在父组件里面写$on的,应该是这样

```html
<parent>
    <child @eventname="event">
</parent>
```
然后在parent组件里面写 event函数.event(){}

子组件调用的时候用``this.$emit('eventname',payload) ``

(2)父组件传播事件给子组件，用 ``$refs``

```html
<parent>
    <child ref="refname">
</parant>
```

调用的时候用``this.$ref['refname'].eventname()``

(3)上面有种都麻烦的话，创建实例bus


###  js的数组可以是这样的形式

``(4) [{…}, {…}, {…}, {…}, total: 4, code: "core.ok", __ob__: Observer]``

他的length是4，不知道是不是ES6的新特性
我把下面这句在浏览器下运行是出错的

``let arr= [{id:1}, {id:2}, {id:3}, {id:4}, total: 4, code: "core.ok"];``
    
### 把字符串转换成数字可以用数字运算符,但是 + 不行
```javascript
console.log("2">>>0)  //2 number 
console.log("2">>0)  //2 number 
console.log("2"<<0)  //2 number  没有（<<<）
console.log("2"- 0)    //2 number
console.log("2"+0)    //20 string
```

### reduce函数好好用

今天写了一个有重大作用的reduce函数，好开心。在此纪念一下

```javascript
//str {String}, "app.get.logo.list"
//ctx {Object},  this._$http
//return {Object}, this._$http.app.get.logo.list
 getBackend(str){
        const arr = this.loadBackend.split('.');
        let ctx= this._$http;
        let a;
        let b=arr.reduce((prev, cur, idx) => {		        
              a = prev[cur] ;         
            return a;
        },ctx);              
          return b;      
      }
```

### 用mpVue开发小程序了
[https://www.itcodemonkey.com/article/2573.html](https://www.itcodemonkey.com/article/2573.html)

### vue项目中全局引入scss文件的方法
```shell
npm install node-sass --save-dev
npm install sass-loader --save-dev
npm install sass-resources-loader --save-dev
```
修改build/utils.js
```javascript
scss: generateLoaders('sass').concat(
      {
        loader: 'sass-resources-loader',
        options: {
          resources: path.resolve(__dirname, '../src/assets/your.scss')
        }
      }
    )
```

### elementUI的layout问题
el-footer会直接fixed在窗口底部，不好看，

解决方法：el-footer放到el-main里面
```html
<el-container style="height:100%;">
    <el-header class="header" style="height:100px">
        <cty-navbar :navs="navs"></cty-navbar>
    </el-header>

    <el-main>      
        <el-scrollbar wrap-style="overflow-x:hidden;" style="min-height: 800px">
            <div>
                <router-view></router-view>
            </div>           
        </el-scrollbar>
                        
        <el-footer class="footer" style="height:70px">
            <cty-footer></cty-footer>
        </el-footer>
    </el-main>
        
</el-container>
```
### vue路由刷新问题，两个路由对应一个组件，如何能让路由重载
[https://segmentfault.com/q/1010000010844655](https://segmentfault.com/q/1010000010844655)

写在共用组件文件里

```javascript
data(){
...
}
mounted(){...},
 watch: {          
            $route: {
                handler: function (val, oldVal) {
                    this.worksheet_type = this.$route.params.type;                     
                },
                deep: true
            }
        },
```
在共用组件上加上key
``<div :key="$route.path">``

## JS运行机制
执行栈,任务队列

``process.nextTick``方法可以在当前"执行栈"的尾部----下一次Event Loop（主线程读取"任务队列"）之前----触发回调函数

``setImmediate``方法则是在当前"任务队列"的尾部添加事件

``process.nextTick``指定的回调函数是在本次"事件循环"触发，而setImmediate指定的是在下次"事件循环"触发

``setTimeout(fn,0)``表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。

``Promise``，里面的函数是直接执行的.

``Promise`` 的 then 应当会放到当前 "执行栈"的尾部

{% asset_img js_zhan_duilie.jpg js堆栈 %}


### 单行文本超出隐藏并显示省略号
```css
.element{
width: 20em;/*不允许出现半汉字截断*/
overflow: hidden; /*自动隐藏文字*/
text-overflow: ellipsis;/*文字隐藏后添加省略号*/
white-space: nowrap;/*强制不换行*/
```

### 多行文字隐藏加省略号
```css
.element{
    width: 20em;
    height: 3em;/*注意高度和宽度，不允许出现半汉字截断*/
    line-height: 1.5em;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
}
```